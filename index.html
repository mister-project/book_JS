<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>book_JS</title>
    <link rel="stylesheet" href="./style.css">
    <script src="./contents.js" defer></script>
    <!-- <script src="./script2.js" defer></script> -->
    <!-- <style>
        #toc {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #f8f8f8;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
    </style> -->
    <style>
        ul {
            padding: 0;
            margin: 0;
            /* Убираем отступы у списка */
        }
    </style>
</head>

<body>
    <div id="contents"></div>
    <div id="toc">
        <input type="button" value="X" id="btn1">
    </div>
    <pre>/
<h1>HTML</h1>
<h2>Работа с VS Code</h2>
тэг img вызывает такую строку и нужен для вставки картинки <img src="" alt="">

Команда <strong>"Ctrl + Пробел"</strong>  между кавычками позволяет увидеть все древо файлов
<h2>Тэги 'ol>li>ul>a>' </h2>

    тег ol + теги li создают нумерованный список
    <!-- <blockquote>  -->
     <ol>
        <li>авыаы</li>
        <li>ыаыаы</li>
        <li>ыаыа</li>
        <li>ыаыа</li>
        
    </ol>


    тег ul + теги li создают МАРКИРОВАННЫЙ список
    <ul>
        <li>ыаыавы</li>
        <li>ыаыаыа</li>
        <li>ыаыаыа</li>
        <li>ыаыаыа</li>
        
    </ul>
<!-- </blockquote> -->

    <H2>Тэги table td, tr, </H2>   

    table border - таблица и толщина границы
    caption - название таблицы - указывается после тега table
    <caption>Название таблицы</caption>
    tr - сторока
    td - столбец

    <h2>Тэги div, span, p, hr</h2>
    span - аналог div, но строчный элемент
    div - выделает блок
    p - выделяет абзац, отличие от div: p нельзя вставить друг в друга и применимы больше для текста
    hr - добавляет разделительную линию
    h1-h6 - Заголовки 

    <h2>Формы</h2>
    <form action="тег form">
        <button>тэг button</button>
        <textarea name=" id="" cols="30" rows="10">тэг textarea"</textarea>
        <span>тип - select</span>
        <select name="" id=""> 
            <option value="">Текст1</option>
            <option value="">Текст2</option>
            <option value="">Текст3</option>
        </select>

<div>дальше пошли тэги - разновидности INPUT</div>
    <input type="text"> <span>тип - text</span>
    <input type="checkbox"> <span>тип - checkbox</span>
    <input type="color"> <span>тип - color</span>
    <input type="date"> <span>тип - date</span>
    <input type="datetime-local"> <span>тип - datetime-local</span>
    <input type="email"> <span>тип - email</span>
    <input type="file"><span>тип - file</span>
    <input type="hidden"><span>тип - hidden</span>
    <input type="image" src="https://64.media.tumblr.com/fd49ffd9eb3803245ad337963005f3bb/tumblr_o45y6ipRAY1qehul1o1_250.png" alt=""><span>тип - image</span>
    <input type="password"><span>тип - password</span>
    <input type="month"><span>тип - month</span>
    <input type="number"><span>тип - number</span>
    <input type="radio"><span>тип - radio</span>
    <input type="reset"><span>тип - reset </span>
    <input type="search"><span>тип - search</span>
    <input type="submit"><span>тип - submit</span>
    <input type="tel"><span>тип - tel</span>
    <input type="time"><span>тип - time</span>
    <input type="url"><span>тип - url</span>
    <input type="week"><span>тип - week</span>

    </form>
    
<h2>Атрибуты тэгов + СLASS И id </h2>
Возьмем, к примеру тэг 
div и добавим атрибуты hidden и title
<xmp>
    <div hidden = "hidden">
    <div title = "hidden" style="margin: 0;">Lorem, ipsum dolor sit amet consectetur adipisicing elit. Ipsam, vel?
    </div>
    Так же мы часто используем атрибуты class и id, имеющие более широкое применение
    <div class="123" id="123">
        
    </div>    
</xmp>
<p style="color: red; margin: 0px; border: 0px;padding: 0;">!!!</p>
<div>
    
   
    <li style="margin: 0;">class и id могут совпадать</li>
    <li>id никогда не повторяется</li>
    <li>в одном атрибуте через пробел может быть записано несколько классов, например: <div class="class1 class2"></div></li>
</ol>
</div>

<h2>CSS селекторы</h2>
<h3>CSS Терминология</h3>
<xmp>В записи css- файла:
* {
    color: red;
}
color - это свойство
red - его значение
</xmp>
1. <b>Селекторы тэгов</b> , например h1 - указываются в css без точек и др. знаков. <br>Пример:
<xmp>
h1 {
}
</xmp>
2. <b>Селекторы класса</b> - перед ними указывается <b>точка</b>
Пример:
<xmp>
    .class1 {

    }
</xmp>
3. <b>Селекторы идентификаторов</b> - перед ними идет <b>#</b>
Пример:
<xmp>
    #id1 {

    }
</xmp>

4. <b>Селектор по атрибуту тэга.</b> - применяются квадратные скобки <B>[]</B>
Пример:
<xmp>
    div[title] {
color: blue;
    }
</xmp>
5. <b>Селектор по атрибуту тэга и его значению</b> - применяются квадратные скобки, равно и кавычки <B>[ = ""]</B>
Пример:
<xmp>
    div[title = "text1"] {
color: blue;
    }
</xmp>

<b>ПРИМЕЧАНИЯ: 
    1. В CSS каждая строчка заканчивается ";"
    2. Свойство CSS, записанное выше, имеет более высокий приоритет</b>

<h2>CSS - работа с картинками</h2>
<b>Прим: чтобы посмотреть список доступных цветов, незабываем нажать на ctrl + Пробел</b>
<xmp>
    p {
        color: blue; - задаем цвет текста
        background-color: red; - задаем цвет фона (background-color: transparent; - задает прозрачный фон)
        background-image: url(../img/logo.png); - задаем картинку на ввиде фона
        background-repeat: no-repeat; - прекращаем повторения картинки на фоне
            
    }
</xmp>
<h2>CSS - Границы элементов border</h2>
Рассмотрим пример задания границы элемента
    <xmp>
        p {
    border: 2px green solid
    border-radius: 10px
}    </xmp>
В этом примере:
    <b>2px</b> - ширина рамки
    <b>green</b> - цвет рамки
    <b>solid</b> - вид рамки (<b>dotted</b> - точки, <b>dashed</b> - пунктирная граница, <b>double</b> - двойная рамка, <b>groove</b> - градиентный окрас... другие настройки - см. в интернете)
    <b>border-radius</b> - параметр скругления. можно настраивать радиус для каждого угла, перечисляя их по часовой стрелке.
    В принципе, настроек по бордерам очень много. Так же можно отдельно настраивать цвет, тип, толщина рамки и другие параметры каждой стороне границы и многое другое
    По углам: если "border-radius: 10px 20px", то первое значение относится к левому верхнему и правому нижнему , 20px - параметра для двух оставшихся углов/
    Если идет 3 значения, например "border-radius: 10px 20px 30px", то 10 - левый верхний, 20 - правый верхний и левый нижний, 30 - правый нижний
    Если 4 значения, "border-radius: 10px 20px 30px 40px", то распределение идет по часовой стрелке, начиная с левого верхнего угла. 

 <h2>CSS Размеры элементов</h2>   
 <xmp>
.logo {
       
        background-image: url(../img/logo.png); - задаем картинку на ввиде фона
        background-repeat: no-repeat; - прекращаем повторения картинки на фоне
        height: 50px; - высота (вводить в редакторе можно 'h50')
        width: 150px; - ширина (вводить в редакторе можно 'w150')
        border: 1px solid black; - порядок указания параметров границ можно менять
        border-top-width: 20px; - ширина границы сверху (btw20)
        border-right-width: 10px; - ширина границы справа (brw10)
        

}</xmp>

<b>Примечание:</b> проконтролировать размеры можно в инструментах разработчика (F12)

<h2>CSS Шрифты</h2>
Пример
<xmp>
    p{
        font-family: serif; (с засечками внизу букв)
        <!-- или  -->
        font-family: sans-serif; (без засечек)
        font-family: monospace; - каждый символ имеет одинаковую ширину (моношринный)
        font-size: 15px; (fz15) - размер шрифта

 Ширину можно задавать словами или цифрами (100-900)
        font-weight: lighter; - тонкая ширина (100) - (fwl)
        font-weight: normal; - нормальная ширина (400) - (fwn)
        font-weight: bold; - широкая ширина (700) - (fwb)
        font-weight: bolder; - широчайшая ширина (900)

        line-height: 30px; - задание межстрочного интервала

Выравнивание текста:
        text-align: center;
        text-align: left;
        text-align: right;
        text-align: justify; - распределение по ширине

Подчеркивания:
        text-decoration: underline; - снизу
        text-decoration: overline; - сверху
        text-decoration: line-through; - зачеркивание
        text-decoration: none; - убирает Подчеркивания (используется, например чтобы убрать подчеркивание у ссылок)

Текст-Трансформ:
        text-transform: uppercase; - все символы заглавные
        text-transform: lowercase; - все символы строчные
        text-transform: capitalize;  - каждое слово с заглавной буквы
    }
</xmp>
<b>Настройка шрифта у списка</b>
<xmp>
    ul {
        list-style: none; - так убираем точки у пунктов списка и далее можно использовать для построения меню
    }
</xmp>
<h2> CSS - БЛОЧНАЯ МОДЕЛЬ</h2>
<xmp>
    <!-- HTML -->

    <div class="box box1"></div>
    <div class="box box2"></div>
    
    <!-- css -->

    .box{ 
        box-sizing: border-box; 
        } -  держит размеры блока в рамках указнных ниже , 
         не смотря на padding и border - ЭТУ НАСТРОЙКУ ЧАСТО 
         УКАЗЫВАЮТ В САМОМ ВЕРХУ ДЛЯ ВСЕХ БЛОКОВ, ПРИМЕР:
         *{
        box-sizing: border-box;     
        width: 150px;
        height: 150px;
        border: 1px solid black;
    }
    .box1 {
        background-color: rgb(212, 91, 91);

        margin: 10px 40px 20px 30px; - меняет отступы снаружи 
        распределяется по часовой стрелке, начиная сверху 
        
        padding: 15px; - можно настроить отдельно для 
        каждой стороны, например :
        padding-top: 10px;    (pt10)
        или 
        margin-left: 15px;    (pt15)
    }
    .box2 {
        background-color: rgb(91, 143, 212);
        margin: 10px;
    }
</xmp>

==<h2>КОМАНДЫ ДЛЯ РАБОТЫ С GIT</h2> ==
<li>git init folder-name — создает репоизторий в папке folder-name. <strong> У файлов в папке появляется значок "U"</strong></li>
<li>git add <путь до файла> — изменить статус файла на отслеживаемый
    git add . — добавить все файлы в отслеживаемые. <strong> После удачного применения появляется буква "А"</strong>
    git remote add origin «url git» — добавить удалённый репозиторий (с сокр. именем origin) с указанным URL</li>
<li>git commit -a -m  - сохранение КОммита</li>

<li>$ git push origin --delete ветка - удаление ветки на сервере (делается до удаления локальной ветки)</li>
<li>git branch -D ветка - локальное удаление ветки (делается после удаления ветки на сервере)</li>

<li>git remote добавляет origin https://github.com/mister-project/book_JS.git - пришивает локальный репозиторий к удаленному на GIY HUB (берется вся сторока на GIT HUB)</li>
<H2>innerHTML</H2> - свойство элемента, меняющее содержание + отзывчивое на верстку
11:58 Создание элементов с нуля
//создание
const newElem = document.createElement('li')
//занесение текста в новый элемент
newElem.textContent = 'step 6'
//присвоение класса новому элементу
newElem.classList.add('elem')
//добавление нового элемента в список
lists[1].append(newElem)

13:15 Еще 3 интересных метода
14;16 ==insertAdjacentText==
//достаем из верстки заголовок (title) по id и присваиваем переременной title

const title = document.getElementById('title')

// записываем в верстку через новую переменную с использованием метода 'insertAdjacentText' новые строки для вставки со
всех сторон от title:

title.insertAdjacentText('beforebegin', 'beforebegin')
title.insertAdjacentText('afterend', 'afterend')
//15;15
title.insertAdjacentText('afterbegin', 'afterbegin ')
title.insertAdjacentText('beforeend', ' beforeend ')

16:10 ===insertAdjacentElement===

title.insertAdjacentElement('beforebegin', elems[0])
title.insertAdjacentElement('afterend', elems[1])

title.insertAdjacentElement('afterbegin', elems[2])
title.insertAdjacentElement('beforeend', elems[3])
====insertAdjacentHTML===

title.insertAdjacentHTML('beforebegin', '<span>step 1</span>')
title.insertAdjacentHTML('afterend', '<span>step 2</span>')

title.insertAdjacentHTML('afterbegin', '<span>step 3</span>')
title.insertAdjacentHTML('beforeend', '<span>step 4</span>')

18:50

17:44

Устаревшие методы:
"appenChild(elem[1])" - перенос элемента (современный метод - "append" - новый метод дает возможость добавить сразу
несколько
элементов, так же - возможность добавить строку)

"insertBefore (elem[5], elem[1])" - перемещает элементы (первый аргумент - что перемещаем, второй - элемент перед
которым. Современный метод "before"
идет перемещение)

"replaceChild(elem[5], elem[1])" - 5 элемент встает вместо 1-го, а 1-й исчезает из верстки. Современный метод -
"replaceWith"

"removeChild(elem[5])" - удаление элемента 5-го. Современная замена - "remove"
</pre>
    <div>
        <h2>===УРОК 11 ===</h2>
    </div>

    js очень часто используется для редактирования интрерфейса <br>
    плюс когда нужна реакция (отработка функции) на некоторые действия пользователя <br>

    <h3>
        Действия пользователя: <br>
    </h3>
    <li>Клик по кнопке</li>
    <li>Наведение курсора на определенное место на странице </li>
    <li>Сужение или расширение нашего экрана</li>
    <li>Клик по любой ссылке</li>
    <li>Отправка формы</li>
    <li>Любой ввод\вывод информации</li>

    <h3>Как мы можем перехватывать действия пользователя:</h3>

    <ol>
        Атрибут на самом элементе (старый способ)
        пример:
        <div>
            <pre class="hljs"
                style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(240, 240, 240); color: rgb(68, 68, 68);">&lt;div <span class="hljs-class"><span class="hljs-keyword" style="font-weight: 700;">class</span></span>=<span class="hljs-string" style="color: rgb(136, 0, 0);">"controls"</span>&gt;

            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name" style="font-weight: 700;">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string" style="color: rgb(136, 0, 0);">"alert('Клик по кнопке')"</span> <span class="hljs-attr">id</span>=<span class="hljs-string" style="color: rgb(136, 0, 0);">"btn"</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name" style="font-weight: 700;">button</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name" style="font-weight: 700;">cite</span>&gt;</span></span>
        &lt;< class="hljs-regexp" style="color: rgb(188, 96, 96);">/div&gt;</

Плохая традиция хранить процедуры в HTML, лучше это делать в отдельном js - файле <br>
Ту же кнопку мы можем выцепить через id в js - файле 
====== <br>
<pre class="hljs" style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(240, 240, 240); color: rgb(68, 68, 68);"><span class="hljs-keyword" style="font-weight: 700;">const</span> btn = <span class="hljs-built_in" style="color: rgb(57, 115, 0);">document</span>.getElementById(<span class="hljs-string" style="color: rgb(136, 0, 0);">'btn'</span>) 
    btn.onclick = <span class="hljs-function"><span class="hljs-keyword" style="font-weight: 700;">function</span>(<span class="hljs-params"></span>) </span>{ 
    alert(<span class="hljs-string" style="color: rgb(136, 0, 0);">'клик по кнопке!'</span>) 
    } </pre>

            <pre class="hljs"
                style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(240, 240, 240); color: rgb(68, 68, 68);"><span class="hljs-keyword" style="font-weight: 700;">Если</span> вывести переменную btn в console.dir, то увидим, что атрибут <span class="hljs-string" style="color: rgb(136, 0, 0);">"onclick"</span> обозначен как <span class="hljs-function"><span class="hljs-keyword" style="font-weight: 700;">функция</span> </span></pre>

            Ищем квадрат

            <pre class="hljs"
                style="display: block; overflow-x: auto; padding: 0.5em; background: rgb(240, 240, 240); color: rgb(68, 68, 68);"><span class="hljs-comment" style="color: rgb(136, 136, 136);">//ищем квадрат</span>
    <span class="hljs-keyword" style="font-weight: 700;">const</span> square = <span class="hljs-built_in" style="color: rgb(57, 115, 0);">document</span>.getElementById(<span class="hljs-string" style="color: rgb(136, 0, 0);">'square'</span>)
    <span class="hljs-comment" style="color: rgb(136, 136, 136);">//создаем функкцию клика</span>
    <span class="hljs-keyword" style="font-weight: 700;">const</span> logger = <span class="hljs-function"><span class="hljs-keyword" style="font-weight: 700;">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in" style="color: rgb(57, 115, 0);">console</span>.log(<span class="hljs-string" style="color: rgb(136, 0, 0);">'клик по квадрату!'</span>)
    }
    <span class="hljs-comment" style="color: rgb(136, 136, 136);">//навешиваем функцию на клик по квадрату</span>
    square.onclick = logger
    
    <span class="hljs-built_in" style="color: rgb(57, 115, 0);">console</span>.dir(square) </pre>
        </div>
        <pre>
    В консоли находим элемент square и активируя его, справа на вкладке Event Listeners (его надо обновлять вручную видим список событий, включая "click"
    мы увидим, что имено в свойстве <strong>handler</strong> храниться функция/
    Если навесить на квадрат, еще одну функцию "logger1", например, то увидим, что в консоли на объекте <strong>square</strong> в свойстве onclick отобразиться только одна функция и это будет наша последняя "logger1"

    const logger = function() {
        console.log('клик по квадрату!')
        }
    const logger1 = function() {
        console.log('клик по квадрату!!!')
        }
    //навешиваем функцию на клик по квадрату
    square.onclick = logger
    square.onclick = logger1
    
    console.dir(square)

<strong>// то, что видим в консоли</strong>
    onclick: ƒ ()
arguments: null
caller: null
length: 0
<STRong>name: "logger1"</STRong>


НО ЕСТЬ СПОСОБ, КАК ЗАПУСТИТЬ 2 функции: ЗАПИШЕМ ONCKLICK В АНОНИМНУЮ ФУНКЦИЮ, 
КОТОРАЯ И БУДЕТ ВЫЗЫВАТЬ 2 ДРУГИЕ

square.onclick = function(){
    logger()
    logger1()
}
<strong>в этом случае в консоли мы увидим:</strong>
div#square
script.js:5 клик по квадрату!
script.js:8 клик по квадрату!!!

НО ВНУТРИ СВОЙСТВА ONCLICK ПО ПРЕЖНЕМУ БУДЕТ ХРАНИТЬСЯ ОДНО ЗНАЧЕНИЕ
- ИМЯ АНОНИМНОЙ ФУНКЦИИ

onclick: ƒ ()
arguments:null
caller: null
length: 0
<strong>name: ""</strong>
08:30 - далее в тетради
//значение функции и события oncklick можно обновить
square.onclick = null

и далее снова навесить другую функцию
square.onclick = function() {
    logger()
} 


Так же можем использовать: addEventListener
const square = document.getElementById('square')
//создаем функцию клика
const logger = function() {
    console.log('клик по квадрату!')
    }

square.addEventListener('click', logger )
// у него 2 агрумента, где мы записываем событие и функцию, привязанную к нему

в консоли получаем: 
клик по квадрату!

так же можно функцию включить прямо в МЕТОД addEventListener:

//ищем квадрат
const square = document.getElementById('square')
//создаем функцию клика
square.addEventListener('click', function() {
    console.log('Клик по квадрату');
})

// и.. результат будет тот же...

==..НУ И НАВЕСИВ СРАЗУ 3 СОБЫТИЯ НА ОДИН КЛИК...

//ищем квадрат
const square = document.getElementById('square')
//создаем функцию клика
square.addEventListener('click', function() {
    console.log('Клик по квадрату');
})

square.addEventListener('click', function() {
    console.log('Клик по квадрату1');
    
})

square.addEventListener('click', function() {
    console.log('Клик по квадрату2');
})

<STRONg>МЫ ПОЛУЧИМ СРАЗУ 3 СОБЫТИЯ В КОНСОЛИ ПОСЛЕ 1 КЛИКА ПО КВАДРАТУ</STRONg>

script.js:5 Клик по квадрату
script.js:9 Клик по квадрату1
script.js:14 Клик по квадрату2

И В БРАУЗЕРЕ (СР. Element/на <div id="square"> \ Event Listeners) уже забито 3 
    события вместо одного в под событием click
   <strong>НА САМОМ ДЕЛЕ НА МЕТОД addEventListener МОЖНО ПОВЕСИТЬ БОЛЬШОЕ КОЛИЧЕСТВО ФУНКЦИЙ</strong> 

   \\ Так же можно остановить работу метода addEventListener методом removeEventListener

   const square = document.getElementById('square')
//создаем функцию клика
const logger = function() {
    console.log('клик по квадрату!')
    }
    
    square.addEventListener('click', logger )
    square.removeEventListener('click', logger )

    после этого и консоль и другие фиксаторы событий будут чисты

    ===НЮАНС - если прописать анонимную функция, то в данном методе она удаляться не будет. Удаляться могут только функции с именем

    const square = document.getElementById('square')
//создаем функцию клика
const logger = function() {
    console.log('клик по квадрату!')
    }
    
    square.addEventListener('click', function() {
        console.log('клик по квадрату2!')
        })
   square.removeEventListener('click', logger )

   В КОНСОЛИ, НЕСМОТРЯ НА <STROng>removeEventListener</STROng> мы получим:
   клик по квадрату2!
====ОБЪЕКТ EVENT
//ищем квадрат
const square = document.getElementById('square')

let counter = 0


//создаем функцию клика
const logger = function(event) {
   console.log(event);
    }
    
    square.addEventListener('click', logger)

Очень много чего мы увидим в консоли

altKey: false - зажата ли кнопка alt
ctrlKey: false - зажата ли клавиша ctrl
target: button#e_btn - свойство нашей цели, по которой мы кликали

//координаты нашего клика:
movementX:0
movementY: 0
offsetX: 42
offsetY: 33
pageX: 662

type: "click" - тип нашего события

Добавим на наш квадрат еще 3 обработчика события:

square.addEventListener('click', logger)
square.addEventListener('mouseup', logger)
square.addEventListener('mousedown', logger)
square.addEventListener('mousemove', logger)

Проведем несколько раз по квадрату и получиммного раз обьект - событие, у которого
type: "mousemove" - тип события mousemove 

Если в консоль выводить event.type, получим

143 mousemove

Если зажать левую кнопку и подвигать мышь, то получим:

script.js:9 mousedown
script.js:9 mousemove
script.js:9 mouseup
script.js:9 click

так же введем взамен изученным новые методы
square.addEventListener('mouseenter', logger)
square.addEventListener('mouseleave', logger)


script.js: mouseenter //получим в консоле при нахождении курсора внутри квадрата
script.js:9 mouseleave //получим в консоле при выходе из квадрата

square.addEventListener('mouseover', logger)
square.addEventListener('mouseout', logger)

Разница перечисленных выше пар:
Если mouseover и mouseout будут так же реагировать (срабатывать) на вложенные элементы,
то mouseenter и mouseleave будут работать только на границах квадрата (или того элемента, на который наложены данные методы)


===РАБОТА С ТЕКСТОВЫМ ИНПУТОМ==

У него в верстке есть идентификатор text
const square = document.getElementById('text')


//создаем функцию клика
const logger = function(event) {
   console.log(event.type);
    }
    
  text.addEventListener('input', logger)
  
--введем в текстовое поле слово text

в итоге, в консоли получим:
  4 input - функция logger отработает 4 раза
  так же input будет срабатывать на удаление, вставку элементов
  то есть от количества символов не зависит от длины текста, а зависит от количества событий с этим полем

  text.addEventListener('input', logger)
  text.addEventListener('focus', logger) - //focus - добавили обработчик с событием фокус
  в консоли получим:
  script.js:7 focus
2script.js:7 input

text.addEventListener('blur', logger)  - // blur - срабатывает, когда фокус убираем из поля

text.addEventListener('change', logger) - //change - отрабатывает, когда значение данного инпута будет изменено

Если изменить параметра вывода функции logger (console.dir(event.target) )

const logger = function(event) {
    console.dir(event.target);
     }

     в значении value мы найдем наш вводимый в текстовое поле текст
     опять измееним параметры вывода:
     console.dir(event.target.value);
==ПОЛУЧИМ В КОНСОЛИ:

script.js:7 s
script.js:7 sd
script.js:7 sdf
script.js:7 sdfs
script.js:7 sdfss
script.js:7 sdfssd
5script.js:7 sdfssdf

<h2> keyup и keydown - нажатие и отпускание клвишы</h2>
text.addEventListener('keyup', logger)
text.addEventListener('keydown', logger)

<h2> РАБОТА С ПОЛОЗКОМ (ДИАПАЗОНОМ)</h2>
const range = document.getElementById('range')
const span = document.getElementById('range-span')


//создаем функцию клика
const logger = function(event) {
   console.dir(event.type);
   span.textContent = event.target.value
    }
    
  range.addEventListener('input', logger)
  range.c('change', logger)

  ===
  Так же можно вешать событития на элементы напрямую (то есть без создания лишних переменных):
  document.getElementById('range').addEventListener('change', logger)



  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM построен');
    //раньше использовалась вместо атрибуту defer
    //Атрибут defer указывает браузеру отложить выполнение скрипта до тех пор, пока не будет завершен разбор HTML-документа. Это позволяет браузеру продолжать отображать содержимое страницы без задержек из-за ожидания скрипта
  ====
    window.onbeforeunload = function () {
        return 'Вы хотите уйти со страницы?'
      }

<> описаный выше метод раньше любили вставить для предупреждения при уходе из окна или страницы. Сейчас его блокируют все современные браузеры. Сейчас это выражается в появлении окна ПЕРЕЗАГРУЗИТЬ САЙТ <br> Изменения могут не сохраниться.</strong>

===<h2>РАБОТО СО ССЫЛКАМИ</h2>

//Пример кода:

//работа со ссылками

const link = document.querySelector('a')
link.addEventListener('click', function(event) {
  event.preventDefault()
console.log('клик по ссылке')
})

//ink.addEventListener('click', function(event) {
    event.preventDefault() - позволяет заблокировать переход на страницу при нажатии на ссылку. Только в консоли появится "4script.js:6 клик по ссылке"

    ===БЛОКИРОВКА ОТКРЫТИЯ МЕНЮ ПРАВОЙ МЫШЬЮ

    document.addEventListener('contextmenu', function(event) {
        event.preventDefault()
        console.log('Где меню?')
===<STRONG>ВСПЛЫТИЕ И ПЕРЕХВАТ</STRONG>

<h2>Наследование</h2>

__proto__ - обращение к вложенному прототипу конструктора

hasOwnProperty - булевый метод, позволяющий определить есть ли у объкта такое свойство

__proto__.__proto__.hasOwnProperty - поиск свойства в прототипе с двойной вложенностью

(frontEndDev.isPrototypeOf(developer1));
isPrototypeOf - булевый метод, подсказывает создан ли объект developer1 
на основании прототипа из объекта frontEndDev


<h2>ПОРТФОЛИО</h2>
портфолио и по сей день актуально
<h2>    Приложение 1. Инструменты веб разработчика</h2>
<a href="https://youtu.be/-2p5mdgjBYA?si=KwzxGi4_QVqjoEy7">Ссылка на ютюб</a>

00:00:31 Разница между сборщиками
• В видео обсуждается разница между сборщиками, такими как Gulp и Webpack, и их роль в веб-разработке.
• Gulp используется для компиляции и оптимизации кода, а Webpack - для модульной работы с JavaScript.

00:09:01 Модульность и сборщики
• В современных проектах используется модульный JavaScript, который собирается в один итоговый файл с помощью сборщиков.
• Webpack и Gulp являются основными сборщиками для JavaScript, но Webpack становится более популярным из-за его удобства и возможностей.

00:11:54 Использование сборщиков в проектах
• В проектах часто используется комбинация Gulp и Webpack для сборки кода и оптимизации ресурсов.
• Webpack используется для сборки клиентского кода, а Gulp - для серверного.

00:13:10 Галп и В-пак
• Галп и В-пак - это разные инструменты для сборки проектов, но их знание полезно для разработчиков.
• Галп сложнее в использовании, но его документация поможет разобраться.
• В-пак после версии 5.38 стал стабильнее и его можно использовать для сборки проектов.

00:17:42 Портфолио и его актуальность
• Портфолио - это резюме разработчика, которое можно использовать для подачи в компанию.
• Портфолио должно быть на английском языке, так как многие компании работают на английском.
• Создать портфолио можно с помощью онлайн-инструмента, такого как онлайн-сиви-билдер.

00:22:47 Создание сайта-портфолио
• Указывается опыт работы, включая последний опыт, и последнее место работы.

• Указывается опыт курирования и курсы.
• Опыт работы в команде ценится больше, чем самостоятельная работа.

00:27:17 Сайт-портфолио на фрилансе
• Сайт-портфолио необходим для фрилансеров, но не обязателен для работы в компании.
• Сайт-портфолио можно сделать на обычном HTML, но лучше использовать фреймворки, такие как Next или Nuxt, для индексации в интернете.

00:30:01 Выбор фреймворка
• Рекомендуется использовать Next или Nuxt для создания сайта-портфолио, так как они дружелюбны и имеют больше возможностей.
• Можно использовать обычный HTML, но это может быть сложнее в редактировании и администрировании.

00:34:43 Отношение к цветным сиви
• Компании могут любить или ненавидеть цветные сиви, поэтому лучше делать ставку на красиво оформленные сиви.
• Человеческий фактор может сыграть роль в том, как компания относится к сиви.

00:35:56 Инструменты для фронтенд-разработки
• Никита обсуждает различные инструменты для фронтенд-разработки, включая сборщики, редакторы кода и браузеры.
• Он рекомендует использовать форк для работы с Git, веб-шторм для фреймворков и веб-шторм для работы с Vue, React или Laravel.
• Он также упоминает, что веб-шторм является мощным инструментом, который облегчает жизнь разработчикам, особенно при работе с фреймворками.

00:43:37 Валидаторы и другие инструменты
• Никита обсуждает валидаторы, такие как валидатор для стиммеля, и упоминает, что он до сих пор использует его для поиска незакрытых тегов.
• Он также упоминает, что браузеры теперь воспринимают ссылки как блочные элементы, и валидатор может не знать об этом.
• Он также упоминает, что Google Lighthouse - это встроенный в браузер инструмент для тестирования страниц, и он может быть использован как npm-пакет.

00:46:22 Обсуждение инструментов и плагинов
• Обсуждение использования сервиса Kena.us для верстки, но автор не использует его в последнее время.
• Упоминается компания Anderson, которая старается использовать минимальное количество классов для оптимизации страниц.
• Валидаторы и джова скрипт для проверки кода.
• Чат G5 как инструмент для разработки, но автор не использует его.
• Второй монитор для работы с YouTube.

00:54:19 Плагины и библиотеки
• Джодит Эдитор - бесплатный аналог платного редактора.
• Импут - плагин для ввода номера телефона.
• Эйр Дейт Питер - дата-пикер для всех платформ, но с отвратительными тайм-питерами.
• Симле Скрул Полифил - для работы с различными материалами.

00:59:40 Использование полифила и других библиотек
• Автор обсуждает использование полифила для решения проблем с скролами и других библиотек, таких как лип набор и интел тайп тел.
• Он также упоминает, что сам пишет библиотеки для своих проектов, предпочитая использовать свой код вместо готовых пакетов.

01:03:33 Вопросы и ответы
• Автор отвечает на вопросы о том, как использовать метод цитап в компонентах, как организовать стейт менеджмент и как использовать бутстрап и галп.
• Он также обсуждает свои планы на будущее, включая выпуск нового курса по Vue.js.

01:12:51 Работа с сайтом и SEO
• Если сайт навьют, лучше делать его в диск, а не на хостинг.
• Можно использовать онлайн-генератор для создания сайта мэп.
• Важно учитывать индексацию сайта и его доступность для онлайн-генераторов.
 
01:14:44 Вопросы и ответы
• SEO как таковое сдохло, но есть специалисты, которые могут настроить метатеги и кейворцы.
• Майские праздники: 12 числа будет трансляция, но возможны паузы и отсрочки по домашним заданиям.

<h2>Курсы Исмаила Усеинова</h2>
<a href="https://stepik.org/users/387773773/teach">ФСЕ Курсы Исмаила Усеинова</a>

<h2>Публикация проекта на GitPages</h2>
<a href="https://www.labwebs.ru/100_soft/2_sborka/1_Webpack/3_deploy/1_state/1_state.php">Ссылка на инструкцию 1 Для WebPack (текст)</a>
<a href="https://www.youtube.com/watch?v=IfBhttjIDUc">Видео-инструкция</a>
</body>


</html>

</pre>